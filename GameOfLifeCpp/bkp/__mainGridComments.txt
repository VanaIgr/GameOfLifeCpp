/*void updateGrid() {
	const GridCell(&g)[] = (GridCell(&)[]) grid;
	const size_t gw = gridWidth;
	const auto isCell = [g](size_t index) -> bool { return g[index] == GridCell::ALIVE; };
	const auto updatedCell = [](const GridCell cell, const unsigned char aliveNeighbours) -> GridCell { 
		if (cell == GridCell::DEAD && aliveNeighbours == 3) {
			return GridCell::ALIVE;
		}
		else if (cell == GridCell::ALIVE && (aliveNeighbours < 2 || aliveNeighbours > 3)) {
			return GridCell::DEAD;
		}
	};
	const size_t topRow = gw * (gridHeight - 1);
	const size_t lastElement = gw - 1;
	unsigned char r1[gridWidth];
	unsigned char r2[gridWidth];
	unsigned char (*topRowNeighbours)[gridWidth] = &r1;
	unsigned char (*curRowNeighbours)[gridWidth] = &r2;

	for (size_t i = 1; i < gridWidth-1; i++) {
		(*topRowNeighbours)[i] = isCell(topRow + i - 1) + isCell(topRow + i) + isCell(topRow + i + 1);
	}
	(*topRowNeighbours)[0] = isCell(topRow + lastElement) + isCell(topRow + 0) + isCell(topRow + 1);
	(*topRowNeighbours)[lastElement] = isCell(topRow + lastElement - 1) + isCell(topRow + lastElement) + isCell(topRow + 0);

	for (size_t row = 0; row < gridHeight-1; row++) {
		const size_t rowIndex = gw * row;
		for (size_t i = 1; i < gridWidth - 1; i++) {
			const size_t index = i + rowIndex;
			if (g[index] != GridCell::WALL) {
				const unsigned char bottomRowNeighbours = isCell(index + gw - 1) + isCell(index + gw) + isCell(index + gw + 1);
				const unsigned char aliveNeighbours = (*topRowNeighbours)[i] + isCell(index - 1) + isCell(index + 1) + bottomRowNeighbours;

				(*gridBuffer)[index] = updatedCell(g[index], aliveNeighbours);
			}

			(*curRowNeighbours)[i] = isCell(index - 1) + isCell(index) + isCell(index + 1);
		}

		{ //first element
			const unsigned char bottomRowNeighbours = isCell((rowIndex + gw) + lastElement) + isCell((rowIndex + gw) + 0) + isCell((rowIndex + gw) + 1);
			const unsigned char aliveNeighbours = (*topRowNeighbours)[0] + isCell(rowIndex + lastElement) + isCell(rowIndex + 1) + bottomRowNeighbours;

			(*gridBuffer)[rowIndex] = updatedCell(g[rowIndex], aliveNeighbours);

			(*curRowNeighbours)[0] = isCell(rowIndex + lastElement) + isCell(rowIndex + 0) + isCell(rowIndex + 1);
		}
		{ //last element
			const unsigned char bottomRowNeighbours = isCell((rowIndex + gw) + lastElement - 1) + isCell((rowIndex + gw) + lastElement) + isCell((rowIndex + gw) + 1);
			const unsigned char aliveNeighbours = (*topRowNeighbours)[rowIndex + lastElement] + isCell(rowIndex + lastElement - 1) + isCell(rowIndex + 0) + bottomRowNeighbours;

			(*gridBuffer)[rowIndex] = updatedCell(g[rowIndex], aliveNeighbours);

			(*curRowNeighbours)[0] = isCell(rowIndex + lastElement - 1) + isCell(rowIndex + lastElement) + isCell(rowIndex + 0);
		}

		auto tmp = topRowNeighbours;
		topRowNeighbours = curRowNeighbours;
		curRowNeighbours = tmp;
	}

	{ //bottom row
		for (size_t i = 1; i < gridWidth - 1; i++) {
			const size_t index = i + topRow;
			const unsigned char bottomRowNeighbours = isCell(i - 1) + isCell(i) + isCell(i + 1);
			const unsigned char aliveNeighbours = (*topRowNeighbours)[i] + isCell(index - 1) + isCell(index + 1) + bottomRowNeighbours;

			(*gridBuffer)[index] = updatedCell(g[index], aliveNeighbours);
		}

		{ //first element
			const unsigned char bottomRowNeighbours = isCell(0 + lastElement) + isCell(0 + 0) + isCell(0 + 1);
			const unsigned char aliveNeighbours = (*topRowNeighbours)[0] + isCell(topRow + lastElement) + isCell(topRow + 1) + bottomRowNeighbours;

			(*gridBuffer)[topRow + 0] = updatedCell(g[topRow + 0], aliveNeighbours);
		}
		{ //last element
			const unsigned char bottomRowNeighbours = isCell(0 + lastElement-1) + isCell(0 + lastElement) + isCell(0 + 0);
			const unsigned char aliveNeighbours = (*topRowNeighbours)[lastElement] + isCell(topRow + lastElement - 1) + isCell(topRow + 0) + bottomRowNeighbours;

			(*gridBuffer)[topRow + lastElement] = updatedCell(g[topRow + lastElement], aliveNeighbours);
		}
	}

	auto tmp = grid;
	grid = gridBuffer;
	gridBuffer = tmp;
}*/

/*GridCell updatedCell(const uint32_t index) {
	GridCell cell = (*grid)[index];

	if (cell != GridCell::WALL) {
		uint32_t aliveNeighbours = 0;

		for (int yo = -1; yo <= 1; yo++) {
			for (int xo = -1; xo <= 1; xo++) {
				if (xo != 0 || yo != 0) {
					const auto offset = vec2i{ xo, yo };
					int x = ((index + xo) + gridWidth) % gridWidth,
						y = (((index / gridWidth) + yo) + gridHeight) % gridHeight;
					int offsetedIndex = x + gridWidth * y;
					if (grid[offsetedIndex] == GridCell::ALIVE)
						aliveNeighbours++;
				}
			}
		}

		if (cell == GridCell::DEAD && aliveNeighbours == 3) {
			return GridCell::ALIVE;
		}
		else if (cell == GridCell::ALIVE && (aliveNeighbours < 2 || aliveNeighbours > 3)) {
			return GridCell::DEAD;
		}
	}

	return cell;
}

void updateGrid() {
	for (size_t i = 0; i < gridSize; i++) {
		(*gridBuffer)[i] = updatedCell(i);
	}

	auto tmp = grid;
	grid = gridBuffer;
	gridBuffer = tmp;
}

void updateGrid_() {
	const auto &g = *grid;
	const auto gw = gridWidth;
	const auto gh = gridHeight;
	const auto updatedCell = [](const GridCell &cell, const unsigned char aliveNeighbours) -> GridCell {
		if (cell == GridCell::DEAD && aliveNeighbours == 3) {
			return GridCell::ALIVE;
		}
		else if (cell == GridCell::ALIVE && (aliveNeighbours < 2 || aliveNeighbours > 3)) {
			return GridCell::DEAD;
		}
		else return cell;
	};
	const auto isCell = [&g](size_t index) -> bool { return g[index] == GridCell::ALIVE; };
	const auto asIndex = [gw, gh](const int32_t row, const int32_t i) -> size_t { return size_t(mod(row, gh) * int32_t(gw) + mod(i, gw)); };
	const auto isCellCoord = [&asIndex, &isCell](const int32_t row, const int32_t i) -> bool { return isCell(asIndex(row, i)); };

	unsigned char r1[gw];
	unsigned char r2[gw];
	unsigned char(*topRowNeighbours)[gridWidth] = &r1;
	unsigned char(*curRowNeighbours)[gridWidth] = &r2;

	const int topRow = (gh - 1) * gw;
	for (size_t i = 0; i < gw; i++) {
		(*topRowNeighbours)[i] = isCellCoord(topRow, i - 1) + isCellCoord(topRow, i) + isCellCoord(topRow, i + 1);
	}

	for (int32_t row = 0; row < gh; row++) {
		for (int32_t i = 0; i < gw; i++) {
			const size_t index = asIndex(row, i);
			if (g[index] != GridCell::WALL) {
				const unsigned char bottomRowNeighbours = isCellCoord(row+1, i-1) + isCellCoord(row + 1, i) + isCellCoord(row + 1, i + 1);
				//const unsigned char topRowNeighbours = isCellCoord(row - 1, i - 1) + isCellCoord(row - 1, i) + isCellCoord(row - 1, i + 1);
				const unsigned char aliveNeighbours = (*topRowNeighbours)[i] + isCellCoord(row, i - 1) + isCellCoord(row, i + 1) + bottomRowNeighbours;

				(*gridBuffer)[index] = updatedCell(g[index], aliveNeighbours);

				//std::cout << (int)aliveNeighbours << " at " << row << ',' << i << std::endl;
			}

			(*curRowNeighbours)[i] = isCellCoord(row, i - 1) + isCellCoord(row, i) + isCellCoord(row, i + 1);
		}

		//auto tmp2 = topRowNeighbours;
		//topRowNeighbours = curRowNeighbours;
		//curRowNeighbours = tmp2;
	}

	auto tmp = grid;
	grid = gridBuffer;
	gridBuffer = tmp;
}*/